{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Main where

import BloomFilter.Hash (Hashable)
import qualified BloomFilter.Easy as B
import Data.Word (Word8, Word32)
import System.Random (Random(..), RandomGen)
import qualified Data.ByteString as Strict
import qualified Data.ByteString.Lazy as Lazy

import Test.QuickCheck

handyCheck :: Testable a => Int -> a -> IO ()
handyCheck limit =
    quickCheckWith $ stdArgs { maxSuccess = limit }

-- Test case generator
genFalsePositiveRate :: Gen Double
genFalsePositiveRate =
    choose (epsilon, 1 - epsilon)
    where epsilon = 1e-6

-- Use this to filter out values from easyList
(=~>) :: Either a b -> (b -> Bool) -> Bool
-- `either` applies first function if val is Left, otherwise second function
k =~> f = either (const True) f k

-- `element` is generated by quickcheck based on the type signature 
prop_one_present element =
    forAll genFalsePositiveRate $ \errRate ->
        B.easyList errRate [element] =~> \bfilter -> element `B.elem` bfilter

prop_all_present elements =
    forAll genFalsePositiveRate $ \errRate ->
        B.easyList errRate elements =~> \bfilter ->
            all (flip B.elem $ bfilter) elements

main :: IO ()
main = do
    handyCheck 1000 (prop_one_present :: String -> Property)
    handyCheck 1000 (prop_all_present :: [String] -> Property)
